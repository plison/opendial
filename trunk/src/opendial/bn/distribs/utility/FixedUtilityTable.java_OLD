// =================================================================                                                                   
// Copyright (C) 2011-2013 Pierre Lison (plison@ifi.uio.no)                                                                            
//                                                                                                                                     
// This library is free software; you can redistribute it and/or                                                                       
// modify it under the terms of the GNU Lesser General Public License                                                                  
// as published by the Free Software Foundation; either version 2.1 of                                                                 
// the License, or (at your option) any later version.                                                                                 
//                                                                                                                                     
// This library is distributed in the hope that it will be useful, but                                                                 
// WITHOUT ANY WARRANTY; without even the implied warranty of                                                                          
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU                                                                    
// Lesser General Public License for more details.                                                                                     
//                                                                                                                                     
// You should have received a copy of the GNU Lesser General Public                                                                    
// License along with this program; if not, write to the Free Software                                                                 
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA                                                                           
// 02111-1307, USA.                                                                                                                    
// =================================================================                                                                   

package opendial.bn.distribs.utility;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import opendial.arch.Logger;
import opendial.bn.Assignment;
import opendial.bn.distribs.discrete.DiscreteProbDistribution;
import opendial.bn.values.Value;
import opendial.utils.CombinatoricsUtils;

/**
 * Representation of a value/utility distribution as a table mapping each 
 * possible assignment of values to the input variables to a given scalar 
 * number, representing the utility.
 *
 * @author  Pierre Lison (plison@ifi.uio.no)
 * @version $Date:: 2012-06-11 18:13:11 #$
 *
 */
public class FixedUtilityTable implements UtilityDistribution {

	// logger
	public static Logger log = new Logger("ValueTable", Logger.Level.DEBUG);
	
	// the conditional variables
	Set<String> conditionalVars;
	
	// table mapping value assignments for the input nodes (usually including at least 
	// one action node) to a specific utility
	HashMap<Assignment, Double> table;
	
	
	// ===================================
	//  CONSTRUCTION
	// ===================================

	

	/**
	 * Constructs a new utility distribution, with no values
	 */
	public FixedUtilityTable() {
		table = new HashMap<Assignment,Double>();
		conditionalVars = new HashSet<String>();
	}
	
	/**
	 * Constructs a new utility distribution, given the values provided as argument
	 * 
	 * @param values the values
	 */
	public FixedUtilityTable(Map<Assignment,Double> values) {
		this();
		table.putAll(values);
	}
	
	
	/**
	 * Adds a new utility to the distribution, associated with a value assignment
	 * 
	 * @param input the value assignment for the input nodes
	 * @param utility the resulting utility
	 */
	public void setUtility(Assignment input, double utility) {
		table.put(input,utility);
		conditionalVars.addAll(input.getVariables());
	}
	
	
	/**
	 * Adds a set of new utilities to the distribution
	 * 
	 * @param utilities the utilities to add
	 */
	public void setUtilities(Map<Assignment,Float> utilities) {
		for (Assignment a : utilities.keySet()) {
			setUtility(a, utilities.get(a));
		}
	}
	
	
	/**
	 * Increment the utility value for the given input by newUtil
	 * 
	 * @param input the value assignment for the input nodes
	 * @param newUtil the utility increment
	 */
	/** public void incrementUtility(Assignment input, double newUtil) {
		if (table.containsKey(input)) {
			addUtility(input, table.get(input) + newUtil);
		}
		else {
			addUtility(input, newUtil);
		}
	} */
	
	
	/**
	 * Removes a utility from the utility distribution
	 * 
	 * @param input the assignment associated with the utility to be removed
	 */
	public void removeUtility(Assignment input) {
		table.remove(input);
	}


	/**
	 * Changes the identifier of one variable in the table
	 * 
	 * @param oldVarId the old identifier
	 * @param newVarId the new identifier
	 */
	public void modifyVarId(String oldVarId, String newVarId) {
		HashMap<Assignment,Double> newTable = new HashMap<Assignment,Double>();
		for (Assignment input : table.keySet()) {
			Assignment newInput = input.copy();
			if (input.containsVar(oldVarId)) {
				Value value = input.getValue(oldVarId);
				newInput.removePair(oldVarId);
				newInput.addPair(newVarId, value);
			}
			newTable.put(newInput, table.get(input));
		}
		table = newTable;
	}

	
	/**
	 * Normalise the utilities defined in the table by normalising it with
	 * the given probability values
	 * 
	 * @param prob
	 */
	/** public void normaliseUtility(DiscreteProbDistribution distrib) {
		for (Assignment a : table.keySet()) {
			if (distrib.hasProb(new Assignment(), a) 
					&& distrib.getProb(new Assignment(), a) > 0.0f
					&& table.get(a) != 0.0f) {
				table.put(a, table.get(a) / distrib.getProb(new Assignment(), a));
			}
		}
	} */

	
	// ===================================
	//  GETTERS
	// ===================================
		
	
	/**
	 * Returns the utility associated with the specific assignment of values for
	 * the input nodes.  If none exists, returns 0.0f.
	 * 
	 * @param input the value assignment for the input nodes
	 * @return the associated utility
	 */
	public double getUtility(Assignment input) {
		if (table.containsKey(input)) {
			return table.get(input);
		}
		else {
			Assignment trimmedInput = input.getTrimmed(conditionalVars);
			if (table.containsKey(trimmedInput)) {
				return table.get(trimmedInput);
			}
			return 0.0f;
		}
	}
	
	
	
	/**
	 * Returns the set of all possible utilities defined in the distribution
	 * 
	 * @return the set of possible utilities
	 */
	public Set<Double> getPossibleUtilities() {
		Set<Double> possibleValues = new HashSet<Double>();
		for (Assignment assignment : table.keySet()) {
			possibleValues.add(table.get(assignment));
		}
		return possibleValues;
	}
	
	/**
	 * Returns true if the utility distribution if well-formed -- i.e. if it defines
	 * a specific utility for each possible assignment of input values
	 * 
	 * @return true if well-formed, false otherwise
	 */
	public boolean isWellFormed() {
		Map<String,Set<Value>> possiblePairs = 
			CombinatoricsUtils.extractPossiblePairs(table.keySet());
		Set<Assignment> possibleAssignments = 
			CombinatoricsUtils.getAllCombinations(possiblePairs);
		
		for (Assignment assignment : possibleAssignments) {
			if (!table.containsKey(assignment)) {
				log.warning("assignment " + assignment + " not defined in utility distribution");
				return false;
			}
		}
		return true;
	}
	
	
	/**
	 * Returns the table defining the utilities
	 * 
	 * @return the table
	 */
	public Map<Assignment,Double> getTable() {
		return new HashMap<Assignment,Double>(table);
	}
	
	

	/**
	 * Returns the set of (action) assignments that are relevant given the
	 * input conditions provided as arguments.
	 * 	 * 
	 * @param input the input assignment
	 * @return the set of relevant actions
	 */
	@Override
	public Set<Assignment> getRelevantActions(Assignment input) {
		Set<Assignment> relevantActions = new HashSet<Assignment>();
		for (Assignment fullKey : table.keySet()) {
			if (fullKey.consistentWith(input)) {
				Assignment otherHalf = new Assignment(fullKey);
				otherHalf.removePairs(input.getVariables());
				relevantActions.add(otherHalf);
			}
		}
		return relevantActions;
	} 

	

	
	// ===================================
	//  UTILITIES
	// ===================================

	
	/**
	 * Copies the distribution
	 * 
	 * @return the copy
	 */
	public UtilityTable copy() {
		return new UtilityTable(table);
	}
	
	
	/**
	 * Returns a string representation of the distribution
	 *
	 * @return the string representation
	 */
	@Override
	public String toString() {
		String str = "";
		for (Assignment input: table.keySet()) {
			str += "Q(" + input + "):=" + table.get(input) + "\n";
		}
		return str;
	}
	
	/**
	 * Returns a pretty print representation of the distribution
	 * 
	 * @return the pretty print representation
	 */
	public String prettyPrint() {
		return toString();
	}
	
	
	/**
	 * Returns the hashcode for the distribution (computed from the 
	 * hashtable of utilities)
	 *
	 * @return the hashcode
	 */
	@Override
	public int hashCode() {
		return table.hashCode();
	}

	
}
