#summary Advanced modelling aspects when specifying dialogue domains
#sidebar TableOfContents

= Advanced modelling =

== 1. Nested conditions ==

We explained in the section on [DialogueDomains dialogue domains] that rule conditions are essentially defined as conjunctions or disjunctions of basic conditions. If needed, one can also define more advanced, nested conditions, such as for instance A=a1 *and* *not*(B=b1 *or* C!=c1):
{{{
<condition>
  <if var="A" relation="=" value="a1"/>
  <not>
    <or>
      <if var="B" relation="=" value="b1"/>
      <if var="C" relation="!=" value="c1"/>
    </or>
  </not>
</condition>
}}}

Three XML markups are available for such nested conditions: `or`, `and` and `not`, respectively denoting disjunctions, conjunctions and negations.

== 2. References ==

Conditions may be more complex than simple checks between a state variable and a fixed value. For instance, one may want to specify that two variables `A` and `B` must have an identical value (whatever this value might be).  This can be encoded via _variable references_ inside the `value` attribute of an `<if ...>` markup.  References to state variables are denoted with curly brackets { } to distinguish them from usual strings.

For instance, assuming two state variables `firstvar` and `secondvar`, the condition `firstvar==secondvar`` may be written as :
{{{
<if var="firstvar" relation="=" value="{secondvar}"/>
}}}

The condition will therefore be true if e.g. `firstvar=foo` and `secondvar=foo`.  The curly brackets are important: without them, the condition states that the firstvar must have as value the string `secondvar` (instead of the value denoted by the variable).

More complex conditions can be constructed:
{{{
<if var="firstvar" relation="=" value="something({secondvar},{thirdvar})"/>
}}}

The condition will in this case be true if e.g. `secondvar=foo`, `thirdvar=bar`, and `firstvar=something(foo,bar)`.

Variable references may similarly be used in effects:
{{{
<set var="firstvar" value="{secondvar}"/>
}}}
The value of `firstvar` will in this case be assigned to the value of `secondvar`.

Each variable referenced in such a manner is automatically added as an input node of the rule node constructed from the probabilistic rule.


== 3. Quantification ==

The expressivity of probabilistic rules can be greatly improved by introducing universally quantified variables in the rule specification.^[1]^  For instance, one may write a rule that determines how the graspability of an object _X_ depends on its shape:
{{{

<rule id="r3">
  <case>
    <condition>
      <if var="shape({X})" value="sphere"/>
    </condition>
    <effect prob="0.9">
      <set var="graspable({X})" value="true"/>
    </effect>
    <effect prob="0.1">
      <set var="graspable({X})" value="false"/>
    </effect>
  </case>
  <case>
    <condition>
      <if var="shape({X})" value="cone"/>
    </condition>
    <effect prob="0.2">
      <set var="graspable({X})" value="true"/>
    </effect>
    <effect prob="0.8">
      <set var="graspable({X})" value="false"/>
    </effect>
  </case>
</rule>
}}}

The rule will then apply for any arbitrary value _X_ for which a state variable `shape`(_X_) exists in the dialogue state. In order to distinguish the free variable _X_ from normal strings, free variables must be surrounded by curly brackets { }.

Free variables can also be employed in utility rules:
{{{

<rule id="r4">
  <case>
    <condition>
      <if var="task" value="grasp({X})"/>
      <if var="graspable({X})" value="true"/>
    </condition>
    <effect util="2">
      <set var="a_m" value="grasp({X})"/>
    </effect>
  </case>
  <case>
    <effect util="-2">
      <set var="a_m" value="grasp({X})"/>
    </effect>
  </case>
</rule>
}}}

The reader may notice that the same notation (curly brackets) are employed for both references to state variables (cf. above) and free variables.  !OpenDial automatically decides whether the notation represents a reference or a quantified variable by assuming that a given `{X}` represents a reference if the variable X exists in the dialogue state, and will assume that X represents a free variable otherwise.

== 4. String matching ==

Most variables of a dialogue system have values encoded as strings.  !OpenDial includes therefore special functions to easily manipulate strings in probabilistic rules.  Rule conditions can notably applied to perform string matching, as in this example:
{{{

<rule id="r14">
  <case>
    <condition>
      <if var="u_u" value="take the {OBJ}" relation="contains"/>
    </condition>
    <effect>
      <set var="a_u" value="Request({OBJ})"/>
    </effect>
  </case>
</rule>
}}}

The rule above indicates that if the variable `u_u` contains a substring that matches the pattern `take the {OBJ}` (where `{OBJ}` is a placeholder), the variable `a_u` will be set to `Request({OBJ})`.  Note again the use of curly brackets to denote the placeholders.

If the actual content of the slot can be ignored, the placeholder can be replaced by a wildcard:
{{{
<rule>
  <case>
    <condition>
      <if var="u_u" value="turn * left" relation="contains" />
    </condition>
    <effect>
      <set var="a_u" value="Request(Left)" />
    </effect>
  </case>
</rule>
}}}
The above rule will be fired for a user utterance such as "`turn left`", "`turn to the left`", or even "`now robot please turn to the left`" (since the match can be partial). 

== 5. Operations on sets ==

In addition to strings, many state variables also contain collections of elements (for instance, the _n_ most recent dialogue acts, or the list of objects perceived in the current scene).  Probabilistic rules come with built-in functions to manipulate such collections.

==== Conditions on sets: ====

Rule conditions can check for the presence/absence of particular items in a collection, as for instance:
{{{
<if var="somecollection" value="element1" relation="contains"/>
}}}

The condition will therefore be satisfied if `somecollection=[element1,element3]`, but not if `somecollection=[element3]`. In addition to the relation `in`, the relation `!contains` (does not contain) can also be employed in the condition. 

One can also check whether some individual element is contained in a collection through the two relations `in` and `!in`, as for instance:
{{{
<if var="element" value="somecollection" relation="in"/>
}}}

==== Addition and removal of elements: ====

Rule effects can also include special effects to `add`, `remove` or `clear` elements from a collection:
{{{

<rule id="r12">
  <case>
    <condition>
      <if var="A" value="a1" relation="!in"/>
    </condition>
    <effect>
      <add var="A" value="a1"/>
    </effect>
  </case>
</rule>
}}}

The above rule specifies that the value `a1` must be added to the set `A` if it not already included in it.

The `add` markup is used to add a new element to the current set, while `remove` will delete an element.  Finally, `clear` will remove all elements in the set.

== 6. Predictive variables ==

Probability rules can be employed for two distinct purposes.  The first purpose is to update the values of a specific state variable given some new information (for instance, inferring the user dialogue act _a,,u,,_ given the observed user utterance _u,,u,,_). But probability rules can also be used to provide a _prior_ distribution for a future state variable that is expected to be observed in the next time steps.  For instance, the last user intention _i,,u,,_ may be used to predict the next dialogue act from the user.  This prediction does not by itself create a new dialogue act (it's only a prediction), but it can be used as a useful prior for this observation.^[2]^ 

To distinguish these priors from actual observed values, !OpenDial relies on the convention that predictive variables are denoted with a superscript `^p`.  A variable `X^p` represents therefore a prediction on the variable `X` to be observed in the future.

At runtime, !OpenDial will then automatically connect together predicted and observed distributions and derive the resulting posterior distribution.

The following rule from the [SimpleExample step-by-step example] states for instance that, if the system asks the user to repeat, the user is expected to comply (and repeat the same dialogue act) with a probability 0.95.  

{{{
<rule id="repeatpredict">
  <case>
    <condition>
      <if var="a_m" value="AskRepeat" />
    </condition>
    <effect prob="0.95">
      <set var="a_u^p" value="{a_u}" />
    </effect>
  </case>
</rule>
}}}

Note the reference to the existing dialogue act `a_u` in the effect. The above rule allows the system to prime the probability of a repeated dialogue act compared to other hypotheses.

<br><br>

----

^[1]^ See [http://folk.uio.no/plison/pdfs/thesis/thesis-plison2014.pdf Lison (2014)], p. 67-68 and 74-76 for the theoretical foundations of such quantification mechanisms.

^[2]^ See [http://folk.uio.no/plison/pdfs/thesis/thesis-plison2014.pdf Lison (2014)], p. 78-79 for details.