#summary Specifying dialogue domains: advanced modelling

= Advanced modelling =

== 1. Nested conditions ==

We saw in the previous section that the rule conditions were essentially defined as conjunctions or disjunctions of basic conditions. If needed, one can also define more advanced, nested conditions, such as for instance A=a1 *and* *not*(B=b1 *or* C!=c1):
{{{
<condition>
  <if var="A" relation="=" value="a1"/>
  <not>
    <or>
      <if var="B" relation="=" value="b1"/>
      <if var="C" relation="!=" value="c1"/>
    </or>
  </not>
</condition>
}}}

Three XML markups are available for such nested conditions: `or`, `and` and `not`, respectively denoting disjunctions, conjunctions and negations.

== 2. References ==

Conditions may be more complex than simple checks between a state variable and a fixed value. For instance, one may want to specify that two variables `A` and `B` must have an identical value (whatever this value might be).  This can be encoded via _variable references_ inside the `value` attribute of an `<if ...>` markup.  References to state variables are denoted with curly brackets { } to distinguish them from usual strings.

For instance, assuming two state variables `firstvar` and `secondvar`, the condition `firstvar==secondvar`` may be written as :
{{{
<if var="firstvar" relation="=" value="{secondvar}"/>
}}}

The condition will therefore be true if e.g. `firstvar=foo` and `secondvar=foo`.  The curly brackets are important: without them, the condition states that the firstvar must have as value the string `secondvar` (instead of the value denoted by the variable `secondvar`).

More complex conditions must be constructed:
{{{
<if var="firstvar" relation="=" value="Predicate({secondvar}, {thirdvar})"/>
}}}

The condition will in this case be true if e.g. `secondvar=foo`, `thirdvar=bar`, and `firstvar=Predicate(foo,bar)`.

Variable references may similarly be used in effects:
{{{
<set var="firstvar" value="{secondvar}"/>
}}}
The value of `firstvar` will in this case be assigned to the value of `secondvar`.

Each variable referenced in such a manner is automatically added as an input node of the rule node constructed from the probabilistic rule.


== 3. Quantification ==

The expressivity of probabilistic rules can be greatly improved by introducing free variables in the rule specification.  For instance, one may write a rule that determines how the graspability of an object _X_ depends on the object field:
{{{

<rule id="r3">
  <case>
    <condition>
      <if var="shape({X})" value="sphere"/>
    </condition>
    <effect prob="0.9">
      <set var="graspable({X})" value="true"/>
    </effect>
    <effect prob="0.1">
      <set var="graspable({X})" value="false"/>
    </effect>
  </case>
  <case>
    <condition>
      <if var="shape({X})" value="cone"/>
    </condition>
    <effect prob="0.2">
      <set var="graspable({X})" value="true"/>
    </effect>
    <effect prob="0.8">
      <set var="graspable({X})" value="false"/>
    </effect>
  </case>
</rule>
}}}

The rule will then apply for any arbitrary object _X_ that has a state variable `shape`(_X_) in the dialogue state. In order to distinguish the free variable _X_ from normal strings, free variables must be surrounded by curly brackets { }.

Free variables can also be employed in utility rules:
{{{

<rule id="r4">
  <case>
    <condition>
      <if var="task" value="grasp({X})"/>
      <if var="graspable({X})" value="true"/>
    </condition>
    <effect util="2">
      <set var="a_m" value="grasp({X})"/>
    </effect>
  </case>
  <case>
    <effect util="-2">
      <set var="a_m" value="grasp({X})"/>
    </effect>
  </case>
</rule>
}}}

The careful reader may notice that the same notation (curly brackets) are employed for both references to state variables (section 2 above) and free variables.  !OpenDial automatically decides whether the notation represents a reference or a quantified variable by assuming that a given `{X}` represents a reference if the variable X exists in the dialogue state, and will assume that X represents a free variable otherwise.

== 4. String matching ==

Many variables of a dialogue system have values that are encoded as strings.  We integrated therefore special functions to manipulate strings in probabilistic rules.  Rule conditions can notably applied to perform string matching, as in this example:
{{{

<rule id="r14">
  <case>
    <condition>
      <if var="u_u" value="take the {OBJ}" relation="in"/>
    </condition>
    <effect>
      <set var="a_u" value="Request({OBJ})"/>
    </effect>
  </case>
</rule>
}}}

The rule above indicates that if the variable `u_u` contains a substring that matches the pattern `take the {OBJ}` (where `{OBJ}` is a placeholder), the variable `a_u` will be set to `Request({OBJ})`.  Note again the use of curly brackets to denote the placeholders.


== 5. Operations on sets ==

In addition to strings, many state variables also contain collections of elements (for instance, the _n_ most recent dialogue acts).  Probabilistic rules come with built-in functions to manipulate such collections:
 * Rule conditions can check for the presence/absence of particular items in a collection
 * In addition to the standard `set` operation, effects can also include special effects to `add`, `remove` or `clear` elements from a collection:
{{{

<rule id="r12">
  <case>
    <condition>
      <if var="A" value="a1" relation="!in"/>
    </condition>
    <effect>
      <add var="A" value="a1"/>
    </effect>
  </case>
</rule>
}}}

The above rule specifies that the value `a1` must be added to the set `A` if it not already included in it.