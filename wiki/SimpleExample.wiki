#summary A first, step-by-step example of dialogue domain

= A step-by-step example =

Imagine you want to create a simple dialogue controller for a robot that can be instructed to move in four directions: left, right, forward, backward. Probabilistic rules allow us to design such a dialogue controller in a very manner.

== General skeleton == 

We start by creating an XML file with the specification of the dialogue domain.  The top XML node must be `<domain>`:
{{{
<domain>
<!-- the domain specification will go here -->
</domain>
}}}

Each dialogue domain is constituted of a set of (rule-structured) _models_.  A model is essentially a collection of probabilistic rules together with a trigger variable that indicates when the rules should be applied.

In our case, we want to define a model that is triggered when a new user utterance is observed.  We will therefore construct a model with the trigger variable `u_u` (`u_u` is the default label for the user utterance in !OpenDial.  This can be changed in the system settings).  The domain specification becomes therefore:

{{{
<domain>

<model trigger="u_u">
<!-- the rule(s) for this model will go here -->
</model>

</domain>
}}}

Inside each model is a collection of rules. Two distinct types of rules can be encoded:

 * _Probability rules_ express how a subset of state variables (the "input variables" of the rule) affect the probability distribution over some other state variables (the "output variables").

 * _Utility rules_ express the utility of particular actions (from the system perspective) depending on particular state variables. 

== A first rule == 

As we are here interested in mapping a given user utterance to a specific system action, our first rule will be a utility rule. Here is how we can encode the mapping between user and system utterances:

{{{
  <rule>
      <case>
        <condition>
          <if var="u_u" value="turn left" />
        </condition>
        <effect util="1">
          <set var="u_m" value="OK, turning left!" />
        </effect>
      </case>
      <case>
        <condition>
          <if var="u_u" value="turn right" />
        </condition>
        <effect util="1">
          <set var="u_m" value="OK, turning right!" />
        </effect>
      </case>
      <case>
        <condition>
          <if var="u_u" value="move forward" />
        </condition>
        <effect util="1">
          <set var="u_m" value="OK, moving forward!" />
        </effect>
      </case>
      <case>
        <condition>
          <if var="u_u" value="move backward" />
        </condition>
        <effect util="1">
          <set var="u_m" value="OK, moving backward!" />
        </effect>
      </case>
    </rule>
}}}

As we can see, each rule is composed of an ordered list of `case` elements.  Each case is associated with a specific condition and a set of effects (although in this particular rule, there is only one effect in each case).  The rule can be read as such: 
 # *if* the user input `u_u` is equal to "move left", *then* the utility of u_m="OK, moving left" is equal to 1.
 # *else if* the user input `u_u` is equal to "move right", *then* the utility of u_m="OK, moving left" is equal to 1.
 # *else if* the user input `u_u` is equal to "move left", *then* the utility of the u_m="OK, moving left" is equal to 1.
 # *else if* the user input `u_u` is equal to "move left", *then* the utility of the u_m="OK, moving left" is equal to 1.
 # *else* no utility is set.

We can now run !OpenDial, open the domain we have designed, and type for instance `turn left` in the chat window.  

http://opendial.googlecode.com/svn/wiki/example_step1.png

We can also click on the state viewer and inspects both the current dialogue state (in the form of a Bayesian network) and the intermediate states that led to it.

http://opendial.googlecode.com/svn/wiki/example_step1bis.png

== Integrating a NLU model == 

One shortcoming of the current dialogue domain is its rigidity when it comes to the user input.  User utterances such as "turn to the left" or "now move forward" are simply ignored by the system.  Although we could in principle enumerate all possibilities in the utility rule, a better approach is to write an explicit rule that converts the user utterance into a logical representation of the user dialogue act, and then let the utility model operate on this logical representation.


We will therefore write a new model, with one single probability rule:
{{{
  <model trigger="u_u">
    <rule>
      <case>
        <condition operator="or">
          <if var="u_u" value="turn * left" relation="in" />
          <if var="u_u" value="move * left" relation="in" />
          <if var="u_u" value="go * left" relation="in" />
        </condition>
        <effect prob="1">
          <set var="a_u" value="Request(Left)" />
        </effect>
      </case>
      <case>
        <condition operator="or">
          <if var="u_u" value="turn * right" relation="in" />
          <if var="u_u" value="move * right" relation="in" />
          <if var="u_u" value="go * right" relation="in" />
        </condition>
        <effect prob="1">
          <set var="a_u" value="Request(Right)" />
        </effect>
      </case>
      <case>
        <condition operator="or">
          <if var="u_u" value="move * forward" relation="in" />
          <if var="u_u" value="go * forward" relation="in" />
          <if var="u_u" value="go * straight" relation="in" />
        </condition>
        <effect prob="1">
          <set var="a_u" value="Request(Forward)" />
        </effect>
      </case>
      <case>
        <condition operator="or">
          <if var="u_u" value="move * backward" relation="in" />
          <if var="u_u" value="go * backward" relation="in" />
        </condition>
        <effect prob="1">
          <set var="a_u" value="Request(Backward)" />
        </effect>
      </case>
      <case>
        <effect prob="1">
          <set var="a_u" value="Unknown" />
        </effect>
      </case>
    </rule>
  </model>
}}}

A few things are worth noting in this model.  First, the rule conditions are a bit more complicated. Each condition is encoded as a disjunction of basic conditions, as indicated by the attribute `operator`.  

One example of basic condition is 
{{{
          <if var="u_u" value="turn * left" relation="in" />
}}}
This condition will be satisfied if the pattern "turn * left" is found inside the string of the user utterance `u_u`.  See [DialogueDomainsAdvanced#String_matching String matching] for more details on the string matching functionalities integrated in !OpenDial.

The effects themselves specify how output variables (in this case, the user dialogue act `a_u`) must be updated.  In this case, all effects are deterministic.  We will however later encounter rules that define a full probability distributions over alternative effects.


== Integrating a NLG model == 

Instead of directly hard-coding the system utterances as system actions, it is often more appropriate to factor the system decisions in two steps: 
 # The dialogue system first selects a high-level logical representation of the next action,
 # The system then selects the best linguistic realisation for this logical action.

Such an NLG model can be easily constructed with one utility rule:
{{{

<model trigger="a_m">
  <rule>
      <case>
      <condition>
        <if var="a_m" value="Move(Left)"/>
      </condition>
      <effect util="1">
        <set var="u_m" value="Ok, turning left"/>
      </effect>
    </case>
    <case>
      <condition>
        <if var="a_m" value="Move(Right)"/>
      </condition>
      <effect util="1">
        <set var="u_m" value="Ok, turning right"/>
      </effect>
    </case>
    <case>
      <condition>
        <if var="a_m" value="Move(Forward)"/>
      </condition>
      <effect util="1">
        <set var="u_m" value="Ok, moving forward"/>
      </effect>
    </case>
    <case>
      <condition>
        <if var="a_m" value="Move(Backward)"/>
      </condition>
      <effect util="1">
        <set var="u_m" value="Ok, moving backward"/>
      </effect>
    </case>
  </rule>
</model>
}}}

== Clarification strategies ==

The current domain suffers from a lack of robustness in the face of noise and uncertainty.  For instance, if the system observes a user utterance `u_u = move left` with a probability of 0.1 (this can be done in the chat window by adding the probability in parentheses at the end of the utterance), it will ignore the fact that this instruction is highly uncertain and select `Move(Left)` as the next action.

A better approach would be to only execute the action when a certain probability threshold has been reached. One can add the following rule to the action-selection model:
{{{
  <rule>
      <case>
        <effect util="-0.5">
          <set var="a_m" value="Move(*)"/>
        </effect>
      </case>
    </rule>
}}}

This rule will reduce the utility of all `Move(*)` actions by 0.5.  In other words, this means that these actions will only be executed if their probability is higher than 0.5.

We can also add another system action `AskRepeat` to ask the user to repeat the utterance when faced with uncertainty:
{{{
    <rule>
      <case>
        <effect util="0.2">
          <set var="a_m" value="AskRepeat"/>
        </effect>
      </case>
    </rule>
}}}
The NLG rule should also be extended with another case:
{{{
...
  <case>
      <condition>
        <if var="a_m" value="AskRepeat"/>
      </condition>
      <effect util="1">
        <set var="u_m" value="Sorry, could you repeat?"/>
      </effect>
    </case>
 </rule>
}}}

We can test the resulting dialogue domain in the !OpenDial user interface and verify the resulting system behaviour:

http://opendial.googlecode.com/svn/wiki/example_step2.png

== Adding prior distributions ==

The `AskRepeat` action currently encoded in the dialogue domain is not very sophisticated.  It simply asks the user to repeat but does not "accumulate" evidence over the turns.  Assume for instance the dialogue excerpt:
{{{
user:    move forward (0.65)
system:  Sorry, could you repeat?
user:    move forward (0.65)

}}}

With the current dialogue domain, the system will again ask the user to repeat.  The fact that the top hypothesis in both utterances is `move forward` should however give us an increased confidence in the fact that the user intention is indeed `move forward`. 

We can write a rule that encodes the common sense assumption that the user is likely to repeat her/his utterance when asked to do so:
{{{
<!-- Prediction on the next user action -->
<model trigger="a_m">
    <rule>
      <case>
        <condition>
          <if var="a_m" value="AskRepeat" />
        </condition>
        <effect prob="0.9">
          <set var="a_u^p" value="{a_u}" />
        </effect>
      </case>
    </rule>
</model>
}}}

The above rule states that when the system asks the user to repeat, the next user dialogue act is predicted to be identical to the current one with probability 0.9 (the remaining 0.1 covers the cases where the user decides to say something else).

In order to distinguish such prediction on a future event (in this case, the next dialogue act) from actual observed values, OpenDial assumes that predictive variables are denoted with a superscript ^p. A variable X^p represents therefore a prediction on the variable X to be observed in the future (cf. [DialogueDomainsAdvanced#6._Predictive_variables Predictive variables] for details).

The reader should also note that the effect value is `{a_u}`.  This value is a _reference_ to the current value of the the variable `a_u`. The curly brackets { } are important: without them, the effect would simply state that `a_u^p` must be set to the string `"a_u"` instead of referring to the value denoted by the variable (see [https://code.google.com/p/opendial/wiki/DialogueDomainsAdvanced#2._References Variable references] for more details).

Thanks to this rule providing a prior distribution over the next dialogue act, the dialogue system is able to accumulate evidence and select the right action to execute:

http://opendial.googlecode.com/svn/wiki/example_step3.png

== Using quantifiers ==

Some rules in the current dialogue domain seem to include some recurring patterns: for instance, the utility rule for the system action states that, if the user dialogue act has the form `Request`(_some action_), the system can execute the corresponding action `Move`(_some action_) with utility 1.

The expressivity of probabilistic rules can be greatly enriched through the use of _universal quantifiers_.  The rule conditions and effects can indeed be partly underspecified and include free variables.  In other words, the mapping between conditions and effects specified by the rule is duplicated for every possible assignment of values for these free variables.

The utility rule for the selection of the next system action can for instance be simplified into:
{{{
  <rule>
      <case>
        <condition>
          <if var="a_u" value="Request({X})" />
        </condition>
        <effect util="1">
          <set var="a_m" value="Move({X})" />
        </effect>
      </case>
    </rule>
}}}

Note the use of the curly brackets to mark the free variable `X`. 

== Parameters ==



== Final domain specification ==