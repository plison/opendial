#summary A first example of dialogue domain

= A first example =

Imagine you want to create a simple dialogue controller for a robot that can be instructed to move in four directions: left, right, forward, backward. Probabilistic rules allow us to design such a dialogue controller in a very manner.

We start by creating an XML file with the specification of the dialogue domain.  The top XML node must be `<domain>`:
{{{
<domain>
<!-- the domain specification will go here -->
</domain>
}}}

Each dialogue domain is constituted of a set of (rule-structured) _models_.  A model is essentially a collection of probabilistic rules together with a trigger variable that indicates when the rules should be applied.

In our case, we want to define a model that is triggered when a new user utterance is observed.  We will therefore construct a model with the trigger variable `u_u` (`u_u` is the default label for the user utterance in !OpenDial.  This can be changed in the system settings).  The domain specification becomes therefore:

{{{
<domain>

<model trigger="u_u">
<!-- the rule(s) for this model will go here -->
</model>

</domain>
}}}

Inside each model is a collection of rules. Two distinct types of rules can be encoded:

 * _Probability rules_ express how a subset of state variables (the "input variables" of the rule) affect the probability distribution over some other state variables (the "output variables").

 * _Utility rules_ express the utility of particular actions (from the system perspective) depending on particular state variables. 

As we are here interested in mapping a given user utterance to a specific system action, our first rule will be a utility rule. Here is how we can encode the mapping between user and system utterances:

{{{
  <rule>
      <case>
        <condition>
          <if var="u_u" value="turn left" />
        </condition>
        <effect util="1">
          <set var="u_m" value="OK, turning left!" />
        </effect>
      </case>
      <case>
        <condition>
          <if var="u_u" value="turn right" />
        </condition>
        <effect util="1">
          <set var="u_m" value="OK, turning right!" />
        </effect>
      </case>
      <case>
        <condition>
          <if var="u_u" value="move forward" />
        </condition>
        <effect util="1">
          <set var="u_m" value="OK, moving forward!" />
        </effect>
      </case>
      <case>
        <condition>
          <if var="u_u" value="move backward" />
        </condition>
        <effect util="1">
          <set var="u_m" value="OK, moving backward!" />
        </effect>
      </case>
    </rule>
}}}

As we can see, each rule is composed of an ordered list of `case` elements.  Each case is associated with a specific condition and a set of effects (although in this particular rule, there is only one effect in each case).  The rule can be read as such: 
 # *if* the user input `u_u` is equal to "move left", *then* the utility of u_m="OK, moving left" is equal to 1.
 # *else if* the user input `u_u` is equal to "move right", *then* the utility of u_m="OK, moving left" is equal to 1.
 # *else if* the user input `u_u` is equal to "move left", *then* the utility of the u_m="OK, moving left" is equal to 1.
 # *else if* the user input `u_u` is equal to "move left", *then* the utility of the u_m="OK, moving left" is equal to 1.
 # *else* no utility is set.

We can now run !OpenDial, open the domain we have designed, and type for instance `turn left` in the chat window.  

http://opendial.googlecode.com/svn/wiki/example_step1.png

We can also click on the state viewer and inspects both the current dialogue state (in the form of a Bayesian network) and the intermediate states that led to it.

http://opendial.googlecode.com/svn/wiki/example_step1bis.png

 