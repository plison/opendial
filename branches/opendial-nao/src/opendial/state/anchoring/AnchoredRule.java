// =================================================================                                                                   
// Copyright (C) 2011-2015 Pierre Lison (plison@ifi.uio.no)                                                                            
//                                                                                                                                     
// This library is free software; you can redistribute it and/or                                                                       
// modify it under the terms of the GNU Lesser General Public License                                                                  
// as published by the Free Software Foundation; either version 2.1 of                                                                 
// the License, or (at your option) any later version.                                                                                 
//                                                                                                                                     
// This library is distributed in the hope that it will be useful, but                                                                 
// WITHOUT ANY WARRANTY; without even the implied warranty of                                                                          
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU                                                                    
// Lesser General Public License for more details.                                                                                     
//                                                                                                                                     
// You should have received a copy of the GNU Lesser General Public                                                                    
// License along with this program; if not, write to the Free Software                                                                 
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA                                                                           
// 02111-1307, USA.                                                                                                                    
// =================================================================                                                                   

package opendial.state.anchoring;


import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import opendial.arch.Logger;
import opendial.bn.nodes.ChanceNode;
import opendial.datastructs.Assignment;
import opendial.datastructs.ValueRange;
import opendial.domains.rules.RuleCase;
import opendial.domains.rules.Rule;
import opendial.domains.rules.effects.BasicEffect;
import opendial.domains.rules.effects.Effect;
import opendial.state.DialogueState;

/**
 * Representation of a probabilistic rule anchored in a particular dialogue state.
 * 
 * @author  Pierre Lison (plison@ifi.uio.no)
 * @version $Date::                      $
 */
public class AnchoredRule {

	// logger
	public static Logger log = new Logger("AnchoredRule", Logger.Level.DEBUG);

	// the rule
	Rule rule;	
	
	// rule identifier
	String id;
	
	// dialogue state in which the rule is anchored
	DialogueState state;

	// whether the rule is relevant
	boolean relevant = false;
	
	// the range of possible input values for the rule
	ValueRange inputs;
	
	// the range of possible output (or action) values
	ValueRange outputs;
	
	// the set of associated parameters
	Set<String> parameters;
	
	// the possible groundings for the rule
	Set<Assignment> groundings;
	
	// the relevant effects for the rule
	Set<Effect> effects;
	
	// a cache between input assignment and its associated output
	Map<Assignment,Output> cache;

	
	/**
	 * Anchors the rule in the dialogue state.  The construction process leads to the
	 * determination of: <ul>
	 * <li> the relevance of the rule in the given dialogue state
	 * <li> the range of possible values for the input nodes 
	 * <li> the set of parameters associated with the rule
	 * <li> the set of possible groundings for the free variables
	 * <li> the set of possible effects generated by the rule
	 * <li> the set of possible values for the output nodes
	 * </ul>
	 * 
	 * @param rule the probabilistic rule
	 * @param state the dialogue state
	 */
	public AnchoredRule (Rule rule, DialogueState state) {
		this.rule = rule;
		id = rule.getRuleId();
		this.state = state;
		
		if (state.hasNode(id)) {
			log.debug("state: " + state);
			log.warning("rule node " + id + " already exists in state");
		}

		// determines the input range
		inputs = new ValueRange();
		for (ChanceNode inputNode : state.getMatchingNodes(rule.getInputVariables())) {
			inputs.addValues(inputNode.getId(), inputNode.getValues());
		}

		// determines the set of groundings
		groundings = new HashSet<Assignment>();
		Set<Assignment> conditions = inputs.linearise();
		for (Assignment input : conditions) {
			groundings.addAll(rule.getGroundings(input.removePrimes()));
		}
		if (groundings.size() > 1) {
			groundings.remove(new Assignment());
		}

		// determines the set of possible effects, output values and parameters
		// (for all possible input values and groundings)
		effects = new HashSet<Effect>();
		outputs = new ValueRange();
		parameters = new HashSet<String>();
		
		for (Assignment input : conditions) {
			Assignment input2 = input.removePrimes();
			Output output = new Output(rule.getRuleType());
			for (Assignment grounding : groundings) {
				Assignment fullInput = new Assignment(input2, grounding);
				RuleCase matchingCase = rule.getMatchingCase(fullInput);
				if (!matchingCase.equals(new RuleCase())) {
					relevant = true;					
				}
				output.addCase(matchingCase);
			}
			
			for (Effect o : output.getEffects()) {
				parameters.addAll(output.getParameter(o).getParameterIds());		
				effects.add(o);
				for (BasicEffect e : o.getSubEffects()) {
					String outputVar = e.getVariable().getRawString()+"'";
					outputs.addValue(outputVar, e.getValue());
				}
			}
			effects.add(new Effect());
		}
		
		// initialises the output cache
		cache = new HashMap<Assignment,Output>();
	}


	/**
	 * Returns true if the anchored rule is relevant (that is, it at least one matching rule
	 * case is non-empty), and false otherwise.
	 * 
	 * @return true if rule is relevant, and false otherwise.
	 */
	public boolean isRelevant() {
		return relevant;
	}


	/**
	 * Returns the rule identifier
	 * 
	 * @return rule identifier
	 */
	public String getId() {
		return id;
	}
	
	

	/**
	 * Returns the value range for the input variables
	 * 
	 * @return the input range
	 */
	public ValueRange getInputs() {
		return inputs;
	}


	/**
	 * Returns the list of input nodes for the anchored rule
	 * 
	 * @return the input nodes
	 */
	public List<ChanceNode> getInputNodes() {
		List<ChanceNode> nodes = new ArrayList<ChanceNode>();
		for (String param : inputs.getVariables()) {
			if (state.hasChanceNode(param)) {
				nodes.add(state.getChanceNode(param));
			}
		}
		return nodes;
	}
	
	/**
	 * Returns the output variables for the rule
	 * 
	 * @return the output variables
	 */
	public Set<String> getOutputVariables() {
		return outputs.getVariables();
	}
	
	/**
	 * Returns the value range for the output variables
	 * 
	 * @return the output range
	 */
	public ValueRange getOutputs() {
		return outputs;
	}


	/**
	 * Returns the set of possible effects associated with the anchored rule
	 * 
	 * @return set of possible effects
	 */
	public Set<Effect> getEffects() {
		return effects;
	}

	
	/**
	 * Returns the set of possible grounding for the anchored rule
	 * 
	 * @return possible groundings
	 */
	public Set<Assignment> getGroundings() {
		return groundings;
	}

	/**
	 * Returns the rule
	 * 
	 * @return the rule
	 */
	public Rule getRule() {
		return rule;
	}


	/**
	 * Returns the set of parameter nodes for the anchored rule
	 * 
	 * @return the set of parameter nodes
	 */
	public Collection<ChanceNode> getParameters() {
		List<ChanceNode> nodes = new ArrayList<ChanceNode>();
		for (String param : parameters) {
			if (state.hasChanceNode(param)) {
				nodes.add(state.getChanceNode(param));
			}
		}
		return nodes;
	}

	
	/**
	 * Returns the output that is specified for the rule given the particular
	 * assignment of input values. 
	 * 
	 * @param input the input assignment
	 * @return the associated output
	 */
	public Output getMatchingOutput(Assignment input) {

		Assignment input2 = input.removePrimes();
		input2.removeAll(parameters);

		if (cache.containsKey(input2)) {
			return cache.get(input2);
		}
		
		Output output = new Output(rule.getRuleType());
		for (Assignment grounding :groundings) {
			
			Assignment fullInput = new Assignment(input2, grounding);
			RuleCase matchingOutput = rule.getMatchingCase(fullInput);	
			output.addCase(matchingOutput);
		}
		cache.put(input2, output);
		return output;
	}
	
	
	/**
	 * Returns the string representation of the anchored rule
	 * 
	 * @return the string representation
	 */
	public String toString() {
		return rule + " (groundings:"+groundings+")";
	}

}

